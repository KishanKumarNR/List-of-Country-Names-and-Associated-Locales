require "rubygems"
require "json"

module LanguageParser
  extend self

  def run
    # We base this script from a Wikipedia page
    # => http://en.wikipedia.org/wiki/List_of_official_languages_by_state

    # The file has been edited slightly to handle countries listed as having no official language such as the US. 
    # In this situation we use the language used de facto as the country's first language.

    file = File.new("input/wikipedia_full.html", "r")

    results = []
    current_country = nil
    current_languages = []

    while (line = file.gets)
      if line =~ /\A\*[\s]*([\w\s\']*)\b/
        unless current_country.nil?
          results << { current_country => {:languages => current_languages} }
          current_languages = []
        end
        current_country = $1
      end

      current_languages << $1 if line =~ /\A\o[\s]*([\w\s]*)\b/
    end

    file.close

    # Saving all data as JSON
    File.open("output/countries_and_languages_full.json", "w") {|f| f.write(results.to_json) }

    # Saving a simplified version
    simplified = results.map{|r| {r.keys.first =>  r[r.keys.first][:languages].first}}
    File.open("output/countries_and_languages_simplified.json", "w") {|f| f.write(simplified.to_json) }

    # Mapping the results with...
    # =>  Language codes based on ISO 639-1 standard
    #     JSON file based on something generated by Phil Teare using wikipedia data
    # => Country code based on ISO 3166 standard defined on http://www.iso.org/iso/english_country_names_and_code_elements

    json_language_codes = IO.read("input/language_codes.json")
    language_codes = JSON.parse(json_language_codes)

    json_country_codes = IO.read("input/country_codes.json")
    country_codes = JSON.parse(json_country_codes)

    standardized_data = []
    results.each do |result|
      result.each do |k,v|
        standard_languages = v[:languages].map do |language|
          LanguageParserHelper.find_language_code_from_name(language, language_codes)
        end
        standardized_data << {LanguageParserHelper.find_country_code_from_name(k, country_codes) => {:name => k, :languages => standard_languages.compact}}
      end
    end
    File.open("output/countries_and_languages_full_standardized.json", "w") {|f| f.write(standardized_data.to_json) }

    # The follow is for the situation where you want to use this with Facebook.
    # Facebook provided a facebook_targeting_ids.json file containing a list of locales and countries that they support. 
    # This script generate another json that will be compliant with this and will scrap the countries and locales not supported
    facebook_countries_json = IO.read("input/facebook_country_codes.json")
    facebook_countries = JSON.parse(facebook_countries_json)

    facebook_languages_json = IO.read("input/facebook_languages.json")
    facebook_languages = JSON.parse(facebook_languages_json)

    facebook_data = []
    results.each do |result|
      result.each do |k,v|
        standard_languages = v[:languages].map do |language|
          LanguageParserHelper.find_language_code_from_name(language, facebook_languages)
        end
        country_code = LanguageParserHelper.find_country_code_from_name(k, facebook_countries)
        facebook_data << {country_code => {:name => k, :languages => standard_languages.compact}} unless country_code.nil?
      end
    end

    File.open("output/facebook_countries_and_languages_full_standardized.json", "w") {|f| f.write(facebook_data.to_json) }
  end

end



module LanguageParserHelper
  extend self

  def find_language_code_from_name(name, language_codes)
    language_codes.each do |k,v|
      return k if v["name"].strip =~ /#{name}/ # We have to use this to accomodate the syntax of wikipedia
    end
    return nil
  end

  def find_country_code_from_name(name, country_codes)
    country_codes.each do |code|
      return code["id"] if code["value"] == name
    end
    return nil
  end
end


LanguageParser.run


